<section>
    <h3>Using the Cryptic library</h3>
    <pre class="fragment"><code class="scala">
def encrypted(using encrypt: Encrypt): Encrypted[V]
    </code> </pre>
    <pre class="fragment"><code class="scala">
def decrypted(using decrypt: Decrypt): Try[V]
    </code> </pre>
    <aside class="notes">
        <p>The basic usage of the Cryptic library is based on two extension methods:</p>
        <p>To encrypt you use &rarr; <b>encrypted</b><br>
        To decrypt you use &rarr; <b>decrypted</b></p>
        Let's look a <b>encrypted</b> first &rarr;<br>
    </aside>
</section>

<section>
    <h3>Encrypted</h3>
    <pre class="fragment"><code class="scala">
val enc: Encrypted[String] = "secret".encrypted
    </code></pre>
    <pre class="fragment"><code class="scala">
val dec: Try[String] = enc.decrypted
// ==> Success("secret")
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Cryptic makes encryption easy:<br>
                &rarr; Just call <b>encrypted</b> on <i>(in this case)</i> a string.</li>
            <li>&rarr; Decryption is just as easy:<br>
                Call <b>decrypted</b> on an encrypted value and you will get the decrypted value back</li>
            <li>It returns a <b>Try</b>, so you can handle errors.</li>
            <li>You can also operate in encrypted space &rarr;</li>
        </ul>
    </aside>
</section>

<section>
    <h3>Operations</h3>
    <pre class="fragment"><code class="scala">
val enc = "secret sauce".encrypted
    </code></pre>
    <pre class="fragment"><code class="scala">
val upper = enc.map(_.toUpperCase)
    </code></pre>
    <pre class="fragment"><code class="scala">
val snaked = enc.map(_.replace(' ', '_'))
    </code></pre>
    <pre class="fragment"><code class="scala">
val dec = snaked.decrypted
// ==> Success("SECRET_SAUCE")
            </code></pre>
    <pre class="fragment"><code class="scala">
collect, flatMap, filter, filterNot, orElse
    </code></pre>

    <aside class="notes">
        <ul>
            <li>&rarr; Say you want to tranform the secret:</li>
            <li>No need to decrypt anything.</li>
            <li>&rarr; Just call <b>map</b> on the encrypted value</li>
            <li>You get another encrypted value back.</li>
            <li>&rarr; And you can continue to operate.</li>
            <li>&rarr; The operations are staged until you call <b>decrypted</b>.</li>
        </ul>
    </aside>
</section>

<section>
    <h3>Operations continued</h3>
    <pre class="fragment"><code class="scala">
def map[W: Codec](f: V => W)
def flatMap[W: Codec](f: V => Cryptic[W])
def flatten[W : Codec](using ev: V <:< Cryptic[W])
def filter(p: V => Boolean)
def filterNot(p: V => Boolean)
def collect[W: Codec](pf: PartialFunction[V, W])
def orElse[W >: V: Codec](alt: => Cryptic[W])
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Not just <b>map</b> is supported, &rarr; all the expected operations are available.</li>
            <li>This allows you to keep all handling of sensitive information in a separate place in the code or confined to a separate node in your cluster</li>
            <li>Now, let's take a look at the details:</li>
        </ul>
    </aside>
</section>
