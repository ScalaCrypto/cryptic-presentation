<section>
    Using the Cryptic library
    <aside class="notes">
        You need two functions
    </aside>
</section>

<section>
    Encryption<br>
    <!--            <p class="fragment">Use the cryptic library </p>-->
    <pre class="fragment"><code class="scala">
val enc: Encrypted[String] = "secret".encrypted
            </code></pre>
    <aside class="notes">
        Cryptic make using encryption easy.<br>
        Use the encrypted extension on String<br>
        But we also need to decrypt
    </aside>

</section>

<section>
    Decryption<br>
    <pre class="fragment"><code class="scala">
val dec: Try[String] = enc.decrypted
// ==> Success("secret")
            </code></pre>
    <aside class="notes">
        Decryption is also easy to do!.
    </aside>
</section>

<section>
    Operate in encrypted space<br>
    <pre class="fragment"><code class="scala">
val enc = "secret".encrypted
val upper = enc.map(_.toUpperCase)
            </code></pre>
    <pre class="fragment"><code class="scala">
val dec = upper.decrypted
// ==> SECRET
            </code></pre>
    <pre class="fragment">
            <code class="scala">
collect, flatMap, filter, filterNot, orElse
            </code>
            </pre>

    <aside class="notes">
        You can also operate in encrypted space.<br>
        No need for decryption here.<br>
        Allows for keeping sensitive information restricted.<br>
        Not just map<br>
        All the expected operations are available<br>
        But let's look in to the details
    </aside>
</section>
