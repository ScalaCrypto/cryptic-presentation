<section>
    <h3>Using Cryptic</h3>
    <pre class="fragment"><code class="scala">
def encrypted(using encrypt: Encrypt): Encrypted[V]
    </code> </pre>
    <pre class="fragment"><code class="scala">
def decrypted(using decrypt: Decrypt): Try[V]
    </code> </pre>
    <aside class="notes">
        <p>The usage of the <b>Cryptic</b> library is based on two methods:</p>
        <p>To encrypt you use &rarr; <b>encrypted</b><br>
        To decrypt you use &rarr; <b>decrypted</b></p>
        Let's take a look at <b>encrypted</b> first &rarr;<br>
    </aside>
</section>

<section>
    <h3>Encrypted</h3>
    <pre class="fragment"><code class="scala">
val enc: Encrypted[String] = "secret".encrypted
    </code></pre>
    <pre class="fragment"><code class="scala">
val dec: Try[String] = enc.decrypted
// ==> Success("secret")
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Cryptic makes encryption easy:<br>
                &rarr; Just call <b>encrypted</b> on a value</li>
            <li>&rarr; Decryption is just as easy:<br>
                Call <b>decrypted</b> on an encrypted value and you will get the original value back</li>
            <li>It returns a <b>Try</b>, so you can handle errors.</li>
            <li>You can also do operations in encrypted space &rarr;</li>
        </ul>
    </aside>
</section>

<section>
    <h3>Operations</h3>
    <pre class="fragment"><code class="scala">
val enc = "secret sauce".encrypted
    </code></pre>
    <pre class="fragment"><code class="scala">
val upper = enc.map(_.toUpperCase)
    </code></pre>
    <pre class="fragment"><code class="scala">
val snaked = enc.map(_.replace(' ', '_'))
    </code></pre>
    <pre class="fragment"><code class="scala">
val dec = snaked.decrypted
// ==> Success("SECRET_SAUCE")
    </code></pre>
    <aside class="notes">
        <ul>
            <li>&rarr; Say you want to tranform a secret:</li>
            <li>There is no need to decrypt anything here.</li>
            <li>&rarr; Call <b>map</b> on the encrypted value</li>
            <li>You get another encrypted value back.</li>
            <li>&rarr; And you can continue to operate on that value</li>
            <li>&rarr; The operations are staged and only run once you call <b>decrypted</b>.</li>
        </ul>
    </aside>
</section>

<section>
    <h3>More Operations</h3>
    <pre class="fragment"><code class="scala">
def map[W: Codec](f: V => W)
def flatMap[W: Codec](f: V => Cryptic[W])
def flatten[W : Codec](using ev: V <:< Cryptic[W])
def filter(p: V => Boolean)
def filterNot(p: V => Boolean)
def collect[W: Codec](pf: PartialFunction[V, W])
def orElse[W >: V: Codec](alt: => Cryptic[W])
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Not only <b>map</b> is supported, &rarr; the usual operations are also available.</li>
            <li>This allows you to keep all handling of sensitive information<br>
                in a separate place in the code or <br>
                confined to a separate node in your cluster</li>
            <li>Now, let's take a look at the details:</li>
        </ul>
    </aside>
</section>
