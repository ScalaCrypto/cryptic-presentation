<section>
    Using the Cryptic library
    <aside class="notes">
        You need two functions
    </aside>
</section>

<section>
    Encrypted<br>
    <!--            <p class="fragment">Use the cryptic library </p>-->
    <pre class="fragment"><code class="scala">
val enc: Encrypted[String] = "secret".encrypted
            </code></pre>
    <aside class="notes">
        <ul>
            <li>Cryptic makes encryption easy.</li>
            <li>Just use the encrypted extension on <i>in this case</i> a string.</li>
            <li>But we also need to decrypt.</li>
        </ul>
    </aside>

</section>

<section>
    Decrypted<br>
    <pre class="fragment"><code class="scala">
val dec: Try[String] = enc.decrypted
// ==> Success("secret")
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Decryption is just as easy.</li>
            <li>Simply use the decrypted method on an encrypted value.</li>
            <li>It returns a Try, so you can easily handle errors.</li>
        </ul>
    </aside>
</section>

<section>
    Operations on encrypted values<br>
    <pre class="fragment"><code class="scala">
val enc = "secret".encrypted
val upper = enc.map(_.toUpperCase)
    </code></pre>
    <pre class="fragment"><code class="scala">
val dec = upper.decrypted
// ==> SECRET
            </code></pre>
    <pre class="fragment"><code class="scala">
collect, flatMap, filter, filterNot, orElse
    </code></pre>

    <aside class="notes">
        <ul>
            <li>You can also do operations on encrypted values.</li>
            <li>No need for decryption here.</li>
            <li>Allows you to keep all handling of sensitive information in a separate place.</li>
            <li>Not just map, all the expected operations are available.</li>
            <li>But let's look in at the details.</li>
        </ul>
    </aside>
</section>
