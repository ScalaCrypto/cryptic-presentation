<section>
    Using the Cryptic library
    <pre class="fragment"><code class="scala">
def encrypted(using encrypt: Encrypt): Encrypted[V]

def decrypted(using decrypt: Decrypt): Try[V]

    </code> </pre>
    <aside class="notes">
        To encrypt and decrypt<br>
        You use the encrypted and decrypted extensions<br>
        Let's look a encrypted first<br>
    </aside>
</section>

<section>
    Encrypted<br>
    <pre><code class="scala">
val enc: Encrypted[String] = "secret".encrypted
            </code></pre>
    <pre class="fragment"><code class="scala">
val dec: Try[String] = enc.decrypted
// ==> Success("secret")
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Cryptic makes encryption easy.</li>
            <li>Encrypted extension on <i>in this case</i> a string.</li>
            <li>Decryption is just as easy.</li>
            <li>Decrypted method on an encrypted value.</li>
            <li>It returns a Try, so you can handle errors.</li>
            <li>You can operate in encrypted space</li>
        </ul>
    </aside>
</section>

<section>
    Operations on encrypted values<br>
    <pre class="fragment"><code class="scala">
val enc = "secret".encrypted
val upper = enc.map(_.toUpperCase)
    </code></pre>
    <pre class="fragment"><code class="scala">
val dec = upper.decrypted
// ==> Success("SECRET")
            </code></pre>
    <pre class="fragment"><code class="scala">
collect, flatMap, filter, filterNot, orElse
    </code></pre>

    <aside class="notes">
        <ul>
            <li>You can also do operations on encrypted values.</li>
            <li>No need for decryption here.</li>
            <li>Allows you to keep all handling of sensitive information in a separate place.</li>
            <li>Not just map, all the expected operations are available.</li>
            <li>But let's look in at the details.</li>
        </ul>
    </aside>
</section>
