<section>
    AES<br>
    <pre><code class="scala">
override val factoryAlgorithm: String = "PBKDF2WithHmacSHA256"
override val keyAlgorithm = "AES"
override val keyspecIterationCount: Int = 310000
override val keyspecLength: Int = 256

override def newCipher(mode: Int,
      key: SecretKey,
      spec: AlgorithmParameterSpec
  ): Cipher =
    val cipher = Cipher
        .getInstance("PBKDF2WithHmacSHA256/GCM/NoPadding")
    cipher.init(mode, key, spec)
    cipher
    </code></pre>
    <aside class="notes">
        This sets up the AES cipher reasonable secure<br>
    </aside>
</section>

<section>
    AES encrypt<br>
    <pre><code class="scala">
  given encrypt(using passphrase: Passphrase): Encrypt =
        (plainText: PlainText) =>
    val salt = Salt(saltLength)
    val key = keygen(passphrase, salt)
    val iv = newIv()
    val ivSpec = paramSpec(iv)
    val cipherText = encrypt(plainText.bytes, key, ivSpec)

    CipherText(
      plainText.manifest,
      salt.bytes,
      iv.immutable,
      cipherText
    )
            </code></pre>
    <aside class="notes">
        The usage of a Passphrase needs key stretching to be secure<br>
        Which requires a Salt<br>
        AES it self requires an Initial Vector, iv
        Both the salt and iv need to be in cipher text for decrypt<br>
        Key stretching is implemented like this &rarr;<br>
   </aside>
</section>

<section>
    Key stretching<br>
    <pre><code class="scala">
 def keygen(passphrase: Passphrase, salt: Salt): SecretKey =
    val factory = SecretKeyFactory.getInstance(factoryAlgorithm)
    val keySpec =
      new PBEKeySpec(
        passphrase.chars.mutable,
        salt.bytes.mutable,
        keyspecIterationCount,
        keyspecLength
      )
    new SecretKeySpec(
      factory.generateSecret(keySpec).getEncoded,
      keyAlgorithm
    )
    </code> </pre>
    <aside class="notes">
        This is a straightforward usage of the Java API<br>
        Here is an example of how it can be used. &rarr;<br>
    </aside>
</section>

<section>
    Example encrypt<br>
    <pre><code class="scala">
import cryptic.{given,*}
import cryptic.codec.default.given
import cryptic.crypto.Aes.{given, *}

given phrase: Passphrase = Passphrase("correct horse")

val enc = "secret".encrypted
// ==> Encrypted(Encrypted(CipherText(0x0000000400 ... ))
    </code></pre>
    <aside class="notes">
        As we see only the passphrase is needed<br>
        The rest of the complexity is hidden<br>
        Now let's look at decrypting &rAarr;<br>
    </aside>
</section>

<section>
    AES decrypt<br>
    <pre><code class="scala">
given decrypt(using passphrase: Passphrase): Decrypt =
    (cipherText: CipherText) =>
    Try:
      val IArray(manifest, salt, iv, bytes) = cipherText.split
      val key = keygen(passphrase, Salt(salt))
      val ivSpec = paramSpec(iv.mutable)
      val decrypted = decrypt(bytes, key, ivSpec)

      PlainText(decrypted, manifest)
    </code></pre>
    <aside class="notes">
        Decrypt splits the cipher text into parts.<br>
        We need to do the same key stretching to get the secret key<br>
        and call Symmetric.decrypt<br>
        in usages it's very simple &rAarr;<br>
    </aside>
</section>
<section>
    Example decrypt<br>
    <pre><code class="scala">
import cryptic.{given,*}
import cryptic.codec.default.given
import cryptic.crypto.Aes.{given, *}

given phrase: Passphrase = Passphrase("correct horse")

enc.decrypted
// ==> Success("secret")
   </code></pre>
    <aside class="notes">
        Next we look at the Asymmetric trait<br>
    </aside>
</section>
