<section>
  <h3>The Encrypted Method</h3>
  <pre><code class="scala">
extension [V: Codec](value: V)

  def encrypted(using encrypt: Encrypt): Encrypted[V] =
    Encrypted(value, Manifest.empty)

  def encrypted(manifest: Manifest)(using encrypt: Encrypt): Encrypted[V] =
    Encrypted(value, manifest)
    </code></pre>
  <pre class="fragment"><code class="scala">
val enc = "secret".encrypted
// ==> Encrypted[String]
    </code></pre>
  <aside class="notes">
    <ul>
      <li>Any type having a <b>Codec</b> will also have the <b>encrypted</b> extension method</li>
      <li>&rarr; The extension methods provides a simple and convenient API for the user</li>
      <li>Now, let's look at its counterpart: the <b>decrypted</b> method &rarr;</li>
    </ul>
  </aside>
</section>

<section>
  <h3>The Decrypted Method</h3>
  <pre><code class="scala">
case class Encrypted[V: Codec] extends Cryptic[V]
  def decrypted(using decrypt: Decrypt): Try[V]
    </code></pre>
  <pre class="fragment"><code class="scala">
enc.decrypted
// ==> Success("secret")
    </code></pre>
  <aside class="notes">
    All encrypted values have a <b>decrypted</b> method<br>
    &rarr; Given a suitable <b>Codec</b> and a <b>Decrypt</b>-function, <br>
    we can use the <b>decrypted</b> method to get the unencrypted value back (wrapped in a try)<br>
  </aside>
</section>
