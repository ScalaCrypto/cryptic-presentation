
<section>
    <h3>The Reverse Crypto</h3>
    <pre><code class="scala">
given encrypt: Encrypt = (plainText: PlainText) =>
  CipherText(plainText.bytes.reverse)
    </code></pre>
    <pre class="fragment"><code class="scala">
given decrypt: Decrypt = (cipherText: CipherText) =>
  Success(PlainText(cipherText.bytes.reverse))
    </code></pre>
    <pre class="fragment"><code class="scala">
"secret".getBytes
// ==> Array(115, 101, 99, 114, 101, 116)

val enc: Encrypted[String] = "secret".encrypted
// ==> Encrypted(CipherText(Array(116, 101, 114, 99, 101, 115)))

enc.decrypted
// ==> Succsess("secret")
    </code></pre>
    <aside class="notes">
      <ul>
        <li>As shown, the <b>Encrypt</b> function simply reverses the bytes in the <b>PlainText</b></li>
        <li>&rarr; The <b>Decrypt</b> function does the same thing, but to the <b>CipherText</b></li>
        <li>This is all that is needed to be able to use this crypto &rarr;</li>LOOK<br>
        <li>To make things a little more interseting, let's look at a crypto requiring a parameter &rarr;</li>
      </ul>
    </aside>
</section>
