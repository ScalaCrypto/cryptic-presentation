<section>
    Using the Manifest to select a key with an id<br>
    <pre class="fragment"><code class="scala" data-trim data-noescape>
case class Keys(offsets: Map[Int, Int]

extension (n: Int)
  def toManifest: IArray[Byte] =
    ByteBuffer.allocate(4).putInt(n).array().immutable

extension (bytes: IArray[Byte])
  def toKeyId: Int = ByteBuffer.wrap(bytes.mutable).getInt
    </code></pre>
    <aside class="notes">
        Some definitions
    </aside>
</section>

<section>
    <pre><code class="scala" data-trim data-noescape>
 given encrypt(using keys: Keys): Encrypt =
    (plainText: PlainText) =>
      val keyId = plainText.manifest.toKeyId
      val offset = keys.offsets.get(keyId)
      val bytes = plainText.bytes.mutable
        .map(b => (b + offset).toByte).immutable

      CipherText(plainText.manifest, bytes)
    </code></pre>
    <aside class="notes">
        Using the keyId in Manifest to select the key<br>
        CipherText with 2 arrays<br>
        Note, only bytes are encrypted<br>
    </aside>
</section>

<section>
    <pre><code class="scala">
object CipherText:
  def apply(array: IArray[Byte], arrays: IArray[Byte]*): CipherText =
    new CipherText(IArray.join(array, arrays*))
    </code></pre>
    <aside class="notes">
        IArray.join is run length encoding the parts<br>
        We will see in next slide<br>
    </aside>
</section>

<section>
    <pre><code class="scala" data-trim data-noescape>
val keys = Keys(100 -> 1, 200 -> 2)
val enc = "secret".encrypted(100.toManifest)

// "secret".getBytes
// Array(115, 101, 99, 114, 101, 116)
//
// IArray(0, 0, 0, 2,
//         0, 0, 0, 4, 0, 0, 0, 100,
//         0, 0, 0, 6, 116, 102, 100, 115, 102, 117)
    </code></pre>
    <aside class="notes">
        All pieces are present
    </aside>
</section>

<section>
    What about decryption
    <pre class="fragment"><code class="scala" data-trim data-noescape>
val enc.decrypted
// => secret
    </code></pre>
    <aside class="notes">
        Much simpler
    </aside>
</section>

<section>
    <pre><code class="scala" data-trim data-noescape>
given decrypt(using keys: Keys): Decrypt = (cipherText: CipherText) =>
    Try:
      val IArray(manifest, bytes) = cipherText.split
      val keyId = manifest.toKeyId
      val offset = keys.get(keyId)
      val decoded = bytes.map(b => (b - offset).toByte)
      PlainText(decoded, manifest)
    </code></pre>
    <aside class="notes">
        Use the CipherText.split function<br>
        Inverse of IArray.join<br>
        Must match the encode usage<br>
        The key id is available unencrypted in the CipherText
    </aside>
</section>

