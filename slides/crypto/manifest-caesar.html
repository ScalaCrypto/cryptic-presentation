<section>
    Using the Manifest to select a key with an id<br>
    <pre class="fragment"><code class="scala" data-trim data-noescape>
case class Keys(offsets: Map[Int, Int])

extension (n: Int)
  def toManifest: Manifest] =
    ByteBuffer.allocate(4).putInt(n).array().immutable

extension (bytes: IArray[Byte])
  def toKeyId: Int = ByteBuffer.wrap(bytes.mutable).getInt
    </code></pre>
    <aside class="notes">
        Some definitions
    </aside>
</section>

<section>
    <pre><code class="scala" data-trim data-noescape>
given encrypt(using keys: Keys): Encrypt =
  (plainText: PlainText) =>
    val keyId = plainText.manifest.toKeyId
    val offset = keys.offsets.get(keyId)
    val bytes = plainText.bytes.mutable
      .map(b => (b + offset).toByte).immutable

    CipherText(plainText.manifest, bytes)
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Using the keyId in Manifest to select the key.</li>
            <li>Note, only bytes are encrypted</li>
            <li>CipherText with 2 arrays</li>
        </ul>
    </aside>
</section>

<section>
    <pre><code class="scala">
object CipherText:
  def apply(array: IArray[Byte], arrays: IArray[Byte]*) =
    CipherText(IArray.join(array, arrays*))
    </code></pre>
    <aside class="notes">
        <ul>
            <li>IArray.join extension method</li>
            <li>Run length encoding the parts</li>
            <li>We will see in next slide</li>
        </ul>
    </aside>
</section>

<section>
    <pre><code class="scala" data-trim data-noescape>
"secret".getBytes
// ==> Array(115, 101, 99, 114, 101, 116)
    </code></pre>

    <pre class="fragment"><code class="scala">
given keys = Keys(100 -> 1, 200 -> 2)

val enc = "secret".encrypted(100.toManifest)
// ==> IArray(0,   0,   0,   2,
//            0,   0,   0,   4,   0,   0,   0, 100,
//            0,   0,   0,   6, 116, 102, 100, 115, 102, 117)
    </code></pre>

    <pre class="fragment"><code class="scala">
"secret".encrypted(200.toManifest)
// ==> IArray(0,   0,   0,   2,
//            0,   0,   0,   4,   0,   0,   0, 200,
//            0,   0,   0,   6, 117, 103, 101, 116, 103, 118)
    </code></pre>
    <aside class="notes">
        Manifest is encoded in the plain text.
    </aside>
</section>

<section>
    What about decryption?
    <pre class="fragment"><code class="scala" data-trim data-noescape>
given keys = Keys(100 -> 1, 200 -> 2)

val enc.decrypted
// => Success("secret")
    </code></pre>
    <aside class="notes">
        <ul>
            <li>We need the Key map</li>
            <li>No need to give the key id</li>
            <li>Look at implementation</li>
        </ul>
    </aside>
</section>

<section>
    <pre><code class="scala" data-trim data-noescape>
given decrypt(using keys: Keys): Decrypt =
  (cipherText: CipherText) =>
    Try:
      val IArray(manifest, bytes) = cipherText.split
      val keyId = manifest.toKeyId
      val offset = keys.get(keyId)
      val decoded = bytes.map(b => (b - offset).toByte)
      PlainText(decoded, manifest)
    </code></pre>
    <aside class="notes">
        Use the CipherText.split function<br>
        Inverse of IArray.join<br>
        Must match the encode usage<br>
        The key id is available unencrypted in the CipherText
    </aside>
</section>

